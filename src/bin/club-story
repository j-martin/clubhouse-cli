#!/usr/bin/env node
const { execSync } = require('child_process');
const fetch        = require('node-fetch');
const path         = require('path');
const fs           = require('fs');
const chalk        = require('chalk');
const config       = require('../lib/configure.js').loadConfig();
const debug        = require('debug')('club');
const client       = require('../lib/client.js');
const storyLib     = require('../lib/stories.js');
const spin         = require('../lib/spinner.js')();
const log      = console.log;
const logError = console.error;
var program    = require('commander');
var wfs       = [];
var epics     = [];
var members   = [];
var projects  = [];
var wf        = { states: [] };

program
    .usage('[options] <id>')
    .description('Update and/or display story details')
    .option('-a, --archived', 'Update story as archived')
    .option('-c, --comment [text]', 'Add comment to story', '')
    .option('-d, --description [text]', 'Update description of story', '')
    .option('-D, --download', 'Download all attached files', '')
    .option('--download-dir [path]', 'Directory to download files to', '.')
    .option('-e, --estimate [number]', 'Update estimate of story', '')
    .option('-E, --epic [id|name]', 'Set epic of story')
    .option('-f, --format [template]', 'Format the story output by template', '')
    .option('--from-git', 'Fetch story parsed by ID from current git branch')
    .option('--git-branch',
        'Checkout git branch from story slug <mention-name>/ch<id>/<type>-<title>\n' +
        '\t\t\t\tas required by the Git integration: https://bit.ly/2RKO1FF')
    .option('--git-branch-short',
        'Checkout git branch from story slug <mention-name>/ch<id>/<title>')
    .option('-I, --idonly', 'Print only ID of story results', '')
    .option('-l, --label [id|name]', 'Stories with label id/name, by regex', '')
    .option('--move-after [id]', 'Move story to position below story ID')
    .option('--move-before [id]', 'Move story to position above story ID')
    .option('--move-down [n]', 'Move story position downward by n stories')
    .option('--move-up [n]', 'Move story position upward by n stories')
    .option('-o, --owners [id|name]', 'Update owners of story, comma-separated', '')
    .option('-O, --open', 'Open story in browser')
    .option('-q, --quiet', 'Print only story output, no loading dialog', '')
    .option('-s, --state [id|name]', 'Update workflow state of story', '')
    .option('-t, --title [text]', 'Update title/name of story', '')
    .option('--task [text]', 'Create new task on story')
    .option('--task-complete [text]', 'Toggle completion of task on story matching text')
    .option('-y, --type [name]', 'Update type of story', '')
    .parse(process.argv);
spin.setSpinnerString(27);

const main = async () => {
    if (!(program.idonly || program.quiet))
        spin.start();
    try {
        debug('request workflows, members, projects, epics');
        [ wfs, members, projects, epics ] = await Promise.all([
            client.listWorkflows(),
            client.listMembers(),
            client.listProjects(),
            client.listEpics(),
        ]);
        debug('response workflows, members, projects, epics');
        wf = wfs[0];    // TODO: this is always getting the default workflow
    } catch (e) {
        log('Error fetching workflows');
    }
    debug('constructing story update');
    let update = {};
    if (program.archived) {
        update.archived = true;
    }
    if (program.state) {
        const stateMatch = new RegExp(program.state, 'i');
        const newState = wf.states.filter(s => {
            return !!`${s.id} ${s.name}`.match(stateMatch);
        })[0];
        update.workflow_state_id = (newState || {}).id;
    }
    if (program.estimate) {
        update.estimate = parseInt(program.estimate, 10);
    }
    if (program.title) {
        update.name = program.title;
    }
    if (program.description) {
        update.description = program.description;
    }
    if (program.type) {
        const typeMatch = new RegExp(program.type, 'i');
        update.story_type = ['feature', 'bug', 'chore'].filter(t => {
            return !!t.match(typeMatch);
        })[0];
    }
    if (program.owners) {
        const ownerMatch = new RegExp(program.owners.split(',').join('|'), 'i');
        update.owner_ids = members.filter(m => {
            return !!`${m.id} ${m.profile.name} ${m.profile.mention_name}`
                .match(ownerMatch);
        }).map(m => m.id);
    }
    if (program.epic) {
        const epicMatch = new RegExp(program.epic, 'i');
        const epic = epics.filter(s => {
            return !!`${s.id} ${s.name}`.match(epicMatch);
        })[0];
        update.epic_id = (epic || {}).id;
    }
    if (program.label) {
        const labelMatch = new RegExp(program.label.split(',').join('|'), 'i');
        try {
            const labels = await client.listResource('labels');
            update.labels = labels.filter(m => {
                return !!`${m.id} ${m.name}`
                    .match(labelMatch);
            }).map(m => {
                return { name: m.name };
            });
        } catch (e) {
            log('Failed to fetch labels to attach.');
        }
    }
    const hasPositionUpdate = program.moveAfter !== undefined
        || program.moveBefore !== undefined
        || program.moveDown !== undefined
        || program.moveUp !== undefined;
    const hasUpdate = Object.keys(update).length > 0 || hasPositionUpdate;
    debug('constructed story update', update);
    let gitID = [];
    if (program.fromGit || !program.args.length) {
        debug('fetching story ID from git');
        let branch = execSync('git branch').toString('utf-8');
        if (branch.match(/\*.*[0-9]+/)) {
            debug('parsing story ID from git branch:', branch);
            let id = parseInt(branch.match(/\*.*/)[0].match(/[0-9]+/)[0], 10);
            debug('parsed story ID from git branch:', id);
            if (id) {
                gitID.push(id);
            }
        } else {
            stopSpinner();
            logError('No ID found in branch');
            process.exit(2);
        }
    }
    program.args.concat(gitID).map(async (id) => {
        let story;
        try {
            if (program.comment) {
                debug('request comment create');
                await client.createStoryComment(id, program.comment);
                debug('response comment create');
            }
        } catch (e) {
            stopSpinner();
            log('Error creating comment', id);
            process.exit(3);
        }
        try {
            if (program.task) {
                debug('request task create');
                await client.createTask(id, { description: program.task });
                debug('response task create');
            }
        } catch (e) {
            stopSpinner();
            log('Error creating task', id);
            process.exit(3);
        }
        try {
            debug('request story');
            story = await client.getStory(id);
            debug('response story');
        } catch (e) {
            stopSpinner();
            logError('Error fetching story', id);
            process.exit(4);
        }
        try {
            if (program.taskComplete) {
                debug('calculating task(s) to complete');
                const descMatch = new RegExp(program.taskComplete, 'i');
                let tasks = story.tasks.filter(t => t.description.match(descMatch));
                let updatedTaskIds = tasks.map(t => t.id);
                debug('request tasks complete', updatedTaskIds);
                await Promise.all(tasks.map(t => client.updateTask(id, t.id, { complete: !t.complete })));
                debug('response tasks complete');
                story.tasks = story.tasks.map(t => {
                    if (updatedTaskIds.indexOf(t.id) > -1)
                        t.complete = !t.complete;
                    return t;
                });
            }
        } catch (e) {
            stopSpinner();
            log('Error updating tasks', e);
            process.exit(3);
        }
        try {
            if (hasUpdate) {
                if (hasPositionUpdate) {
                    debug('calculating move up/down');
                    let siblings = await storyLib.listStories({
                        state: story.workflow_state_id.toString(),
                        sort:  'state.position:asc,position:asc',
                    });
                    let siblingIds = siblings.map(s => s.id);
                    let storyIndex = siblingIds.indexOf(~~id);
                    if (program.moveAfter) {
                        update.after_id = ~~program.moveAfter;
                    } else if (program.moveBefore) {
                        update.before_id = ~~program.moveBefore;
                    } else if (program.moveUp) {
                        update.before_id = siblingIds[Math.max(0, storyIndex - (~~program.moveUp || 1))];
                    } else if (program.moveDown) {
                        update.after_id = siblingIds[Math.min(siblings.length - 1, storyIndex + (~~program.moveDown || 1))];
                    }
                    debug('constructed story position update', update);
                }
                debug('request story update');
                let changed = await client.updateStory(id, update);
                debug('response story update');
                story = Object.assign({}, story, changed);
            }
        } catch (e) {
            stopSpinner();
            logError('Error updating story', id);
            process.exit(5);
        }
        if (story) {
            debug('hydrating story');
            story.state = wf.states
                .filter(s => s.id === story.workflow_state_id)[0];
            story.epic = epics
                .filter(s => s.id === story.epic_id)[0];
            story.project = projects
                .filter(s => s.id === story.project_id)[0];
            story.owners = members.filter(m => {
                return story.owner_ids.indexOf(m.id) > -1;
            });
            debug('hydrated story');
        }
        if (!program.idonly)
            spin.stop(true);
        if (story) {
            printStory(story);
            if (program.open)
                execSync('open ' + storyURL(story));
        }
        if (program.download) {
            downloadFiles(story);
        }
        if (story && program.gitBranch) {
            if (!config.mentionName) {
                stopSpinner();
                storyLib.checkoutStoryBranch(story, `${story.story_type}-${story.id}-`); // TODO: Remove this deprecation in next release
                logError('Error creating story branch in Clubhouse format');
                logError('Please run: "club install --force" to add your mention name to the config.');
                process.exit(10);
            }
            storyLib.checkoutStoryBranch(story);
        } else if (story && program.gitBranchShort) {
            storyLib.checkoutStoryBranch(story, `${config.mentionName}/ch${story.id}/`);
        }
    });
    stopSpinner();
};

const stopSpinner = () => {
    if (!(program.idonly || program.quiet))
        spin.stop(true);
};

const downloadFiles = (story) => {
    story.files.map(file => {
        const filePath = path.join(program.downloadDir, file.name);
        log(chalk.bold('Downloading file to: ') + filePath);
        return fetch(fileURL(file)).then(res => res.body.pipe(fs.createWriteStream(filePath)));
    });
};

const storyURL = (story) => {
    return `https://app.clubhouse.io/story/${story.id}`;
};

const fileURL = file => `${file.url}?token=${client.requestFactory.token}`;

const printStory = (story) => {
    if (program.idonly) {
        return log(story.id);
    }
    if (program.format) {
        return storyLib.printStory(program)(story);
    }
    const labels = story.labels.map(l => {
        return chalk.bold(`#${l.id}`) + ` ${l.name}`;
    });
    const owners = story.owners.map(o => {
        return `${o.profile.name} (` + chalk.bold(`${o.profile.mention_name}` + ')');
    });

    log(chalk.blue.bold(`#${story.id}`) + chalk.blue(` ${story.name}`));
    log(chalk.bold('Desc:') + `     ${formatLong(story.description || '_')}`);
    log(chalk.bold('Owners:') + `   ${owners.join(', ') || '_'}`);
    log(chalk.bold('Type:') + `     ${story.story_type}/${story.estimate || '_'}`);
    log(chalk.bold('Label:') + `    ${labels.join(', ') || '_'}`);
    log(chalk.bold('Project:') + chalk.bold(`  #${story.project_id} `) + story.project.name);
    if (story.epic) {
        log(chalk.bold('Epic:') + chalk.bold(`     #${story.epic_id} `) + story.epic.name);
    } else {
        log(chalk.bold('Epic:') + '     _');
    }
    log(chalk.bold('State:') + chalk.bold(`    #${story.workflow_state_id} `) + story.state.name);
    log(chalk.bold('Created:') + `  ${story.created_at}`);
    if (story.created_at != story.updated_at) {
        log(chalk.bold('Updated:') + `  ${story.updated_at}`);
    }
    log(chalk.bold('URL:') + `      ${storyURL(story)}`);
    if (story.archived) {
        log(chalk.bold('Archived: ') + chalk.bold(story.archived));
    }
    if (story.completed) {
        log(chalk.bold('Completed: ') + chalk.bold(story.completed_at));
    }
    story.tasks.map(c => {
        log(chalk.bold('Task:     ') + (c.complete ? '[X]' : '[ ]')
            + ' ' + formatLong(c.description));
        return c;
    });
    story.comments.map(c => {
        const author = members.filter(m => m.id === c.author_id)[0]
            || { profile: {} };
        log(chalk.bold('Comment:') + `  ${formatLong(c.text)}`);
        log(`          ${author.profile.name} ` + chalk.bold('at:') + ` ${c.updated_at}`);
        return c;
    });
    story.files.map(c => {
        log(chalk.bold('File:') + `     ${fileURL(c)}`);
        log(chalk.bold('          name:') + `  ${c.name}`);
        return c;
    });
    log();
    return story;
};

const formatLong = (str) => {
    return str.split('\n')
        .join('\n         ');
};

main();
